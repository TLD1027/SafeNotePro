## SafeNote Pro

### Preface

**Challenge Description**:
In the sprawling, high-rise labyrinth of Neo-Kyoto, where neon streams bleed into the perpetually rain-soaked streets, a new challenge echoes through the digital aether. They say the city's most guarded secrets, the very truths of its elite, are locked away within the pristine, impenetrable core of "Safenote Pro" â€” a legendary, unhackable data sanctuary. But now, a cryptic breach has fractured its defenses, leaving its supposed invulnerability a chilling legend.

Your mission, if you choose to accept it, is to navigate the "Neon Nexus" of bytes and exploit the very fabric of Safenote Pro's compromised system. Unravel the intricate memory pathways, manipulate the classified data structures, and dance with the ephemeral keys that shift like ghosts in the machine. Bypass the system's stringent security protocols and exploit the delicate balance of its output routines to reveal the hidden "Magic Number" that governs this fractured domain. The "Session ID," a mosaic of fragmented emojis, hints at a deeper, more volatile truth. Can you sort through the chaos, craft your own digital signature, and ultimately uncover the encrypted 'flag' â€” the hidden secret file â€” before the city's pulse drowns out your last connection? The future of Neo-Kyoto, and perhaps your own, hinges on revealing this elusive truth.

**Points**: 929 pts

**Solves**: 9 solves

### Analysis

The program starts by loading a sandbox that disables `execve` and `execveat`. It also closes the standard error stream and duplicates the standard output to a random file descriptor. This file descriptor is flushed and reopened for every output operation.

The program primarily uses two functions for output, `printf_` and `puts_`. Their logic is quite simple: the first three parameters and the last three are random bytes used as checks. The fourth parameter is the actual argument that is passed directly to the `printf` and `puts` functions. At first glance, this might suggest a format string vulnerability, but dynamic debugging reveals that it cannot be triggered.

The main part of the program has six features: the traditional add, delete, modify, view, sort, and set Session ID. By analyzing the add function, we can restore the structure:

```c
struct Namelist
{
    char *name;
    uint32_t size;
    char *fmt;
    void (*show_func)(uint8_t, uint8_t, uint8_t, char*, uint8_t, uint8_t, uint8_t);
    float *magic_num;
};
```

`Namelist` is a 0x28 byte heap chunk. `name` and `fmt` are heap chunks with user-controllable sizes. `magic_num` is an 8-byte heap chunk that stores a floating-point number. `show_func` is a function pointer that can be either `printf_` or `puts_`. The function for reading the floating-point number is implemented using `strtof`, which requires that the first character, excluding `+` and `-`, must be a digit.

In the delete function, the heap chunks are freed and their pointers are cleared. The modify function can only change the `magic_num`. The view function calls `show_func` to output the `fmt` string and prints the stored floating-point number directly as an integer. Every time `magic_num` is read or written, a check is performed to ensure that the high bits of its address are consistent with the value stored at `0x114514000`. The sort function provides an opportunity to perform a division, allowing the result of `a/b` to be written into `c`, provided that $a \\times b \\neq 0$ and $c == 0$. After the calculation, `qsort` is used to sort the entries based on their `magic_num`. Finally, the set Session ID function finds the maximum and minimum numbers in the sorted array and calculates an ID using the formula $(num - min)/(max - min) \\times 0x1f$. It then writes the last byte of a random number into the Session ID at the calculated index.

#### Vulnerability Point

The obvious vulnerability lies in the set Session ID function. If the sort function does not behave as expected (i.e., `max` is not the true maximum or `min` is not the true minimum), an out-of-bounds write to the heap list can be achieved. Due to the property of NaN (Not a Number) where any comparison involving it returns false, we can disrupt the sorting by creating a NaN in the array. Since the input check prevents us from directly entering "nan", we can achieve this through the division operation in the sort function. Operations that produce NaN include $0/0$ or $inf/inf$. An `inf` (infinity) can be generated by inputting a very large number. Here, we can use a number like `10e2222222222222222` to bypass the input length limit and write an `inf` value. Following this, a simple brute-force script can be used to forge the random number and write a specific byte (`code`) at a specified `offset`:

```cpp
// g++ -std=c++17 -O2 -pthread -o brute brute.cpp
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
#include <cmath>
#include <cstring>
#include <iomanip>
#include <limits>
#include <cstdint>

struct Task {
    uint32_t start;
    uint32_t end;
    int offset;
    uint8_t code;
    std::atomic<bool>* found;
    float* result;

    void operator()() const {
        for (uint32_t u = start; u < end && !found->load(); ++u) {
            if ((u & 0xFF) != code)
                continue;
            float num;
            std::memcpy(&num, &u, 4);
            if (!std::isfinite(num))
                continue;

            float product = num * 0x1f;
            if ((int)product == offset) {
                *result = num;
                found->store(true);
                break;
            }
        }
    }
};

int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <offset> <code>" << std::endl;
        return 1;
    }

    int offset = std::stoi(argv[1]);
    int code = std::stoi(argv[2]);

    if (code < 0 || code > 255) {
        std::cerr << "Code must be between 0 and 255." << std::endl;
        return 1;
    }

    int thread_count = std::thread::hardware_concurrency();
    if (thread_count == 0)
        thread_count = 4;

    std::atomic<bool> found{false};
    float result = 0.0f;
    std::vector<std::thread> threads;

    uint64_t total = 1ULL << 32;
    uint64_t chunk = total / thread_count;

    for (int i = 0; i < thread_count; ++i) {
        uint32_t start = static_cast<uint32_t>(i * chunk);
        uint32_t end = (i == thread_count - 1) ? 0xFFFFFFFF : static_cast<uint32_t>(start + chunk);

        threads.emplace_back(Task{
            start,
            end,
            offset,
            static_cast<uint8_t>(code),
            &found,
            &result
        });
    }

    for (auto& t : threads)
        t.join();

    if (found) {
        std::cout << std::fixed << std::setprecision(10)
                << result << std::endl;
    } else {
        std::cout << "Error: not found." << std::endl;
    }

    return 0;
}
```

#### Analysis of Custom Functions

As mentioned earlier, we can use the out-of-bounds write to modify an address in the heap list. However, dynamic debugging shows that the allocated heap addresses do not align with expectations. Tracing this reveals that the `malloc` and `free` functions (as well as `printf` and `puts`) are custom implementations. This is also why the format string vulnerability cannot be triggered. Analyzing the functions in `libtiny.so` makes the custom allocation and deallocation logic clear:

##### Slab Allocation Strategy

  - The heap space is divided into multiple **slabs**, each 64 KiB in size.
  - Each slab is partitioned into fixed-size slots, e.g., 8, 16, 32, ..., 65536 bytes.
  - The size of the slots is determined by a `class`, with a total of 14 supported size classes (exponential growth).

##### Metadata Management

  - Each slab is described by a `SlabMeta` struct that records its start address, end address, slot class, and pointers to the previous and next meta structures.
    ```c
    typedef struct SlabMeta
    {
        uint32_t slab_start_low32;
        uint32_t slab_end_low32;
        int class;
        struct SlabMeta *prev;
        struct SlabMeta *next;
    } SlabMeta;
    ```
  - All `SlabMeta` structures are linked in a doubly-linked list, which facilitates finding the corresponding class for a given address (needed during free).

-----

##### malloc() Allocation Flow Analysis

1.  **Calculate Class**
      - `alignment = 1 << SMP_MIN_CLASS = 8` (default 8-byte alignment).
      - Find the smallest slot size that meets the required `len`.
2.  **Prioritize from Freelist**
      - If the freelist for the corresponding class is not empty, take the head node and return it.
      - It also verifies that:
          - Its high 32 address bits match the current heap's high bits.
          - The freelist's counter matches the actual number of nodes (to prevent list corruption).
3.  **Create a New Slab if Current One is Insufficient**
      - If the slab is empty, request 64 KiB of memory from `sbrk`.
      - On first use, initialize the high 32-bit mapping and save it in a read-only `mmap` region (`0x114514000`).
      - Register the new slab in the `slab_meta` linked list, recording its address range.
4.  **Allocate a Slot**
      - Return a slot from the current slab.
      - Verify the high 32 bits, zero out the memory, and then return it.

-----

##### free() Deallocation Logic Analysis

1.  **Address Validity Check**
      - The address must not be null.
      - The high 32 bits of the address must match the value returned by `get_heap_high32()`.
2.  **Find Slab Class**
      - Traverse the `slab_meta` linked list to find the class corresponding to the address.
      - If no slab is found, it indicates an invalid free (e.g., not allocated or out-of-bounds).
3.  **Add to Freelist**
      - Insert the current pointer at the head of the freelist for the specified class.
4.  **Check Freelist Integrity**
      - Use a fast-slow pointer algorithm to detect cycles in the list (to prevent double free).
      - Simultaneously count the total number of nodes and compare it with `freelist_count` to ensure no memory corruption has occurred.

##### Output Function Logic

The only difference between the two output functions is that `puts` adds a newline character. Unlike their counterparts in glibc, these functions can only output visible characters.

#### Leaking Addresses

Once we understand the heap deallocation logic, we can cause a misaligned free. This allows the `magic_num` pointer of a previously allocated `Namelist` struct to overlap with the `name` chunk of the next `Namelist` struct. When the second `Namelist` is allocated, its `name` chunk will overwrite the original `magic_num` chunk. Then, by freeing the second `Namelist`, its `name` chunk (which is now pointed to by the first `Namelist`'s `magic_num`) is placed into the freelist. At this point, the `magic_num` of the first `Namelist` points to a heap address, allowing us to leak the low bits of a heap address.

To facilitate further exploitation, we construct the following `numlist`:

> 0, ... 0, nan, num, nan, 1, ... 1

This way, the `num` placed between two `nan`s can be edited arbitrarily without disrupting the sorted order of the `Namelist`. Since we have already obtained the low bits of a heap address, we can now change the heap list to point to any heap address. Consider the following scenario:

There exists a four-level pointer chain in the heap (e.g., in a freelist):

> A --\> B --\> C --\> D

If we set `A` as the `magic_num` of a `Namelist`, then the low bits of `C` can be arbitrarily edited by the user, because `B` is a valid "heap address".

Now, if `B` is also set as the `magic_num` of another `Namelist`, since we can only modify the low bits of `C`, `C` remains a valid "heap address". Therefore, by coordinating these two `Namelist`s, we can achieve arbitrary read and write operations on both ELF and heap addresses (since their high bits are the same in most cases). This allows us to smoothly leak the heap address, ELF address, and libc address.

#### Hijacking Program Execution Flow

Since there is a `show_func` pointer in the heap, we only need to hijack this pointer to take control of the program's execution flow. However, due to the sandbox, we cannot directly get a shell using a one-gadget. Observing the register state at this point, it's easy to see that `rcx` holds the address of the `fmt` string, and `r12` is a writable stack address. We can find a gadget like this:

```assembly
.text:0000000000162DA3                 mov     rdi, xdrs
.text:0000000000162DA6                 call    rcx
.text:0000000000162DA8                 test    eax, eax
.text:0000000000162DAA                 jz      loc_162F10
.text:0000000000162DB0                 mov     esi, [rsp+0F8h+shipnow] ; sendnow
.text:0000000000162DB4                 mov     rdi, xdrs       ; xdrs
.text:0000000000162DB7                 call    __GI_xdrrec_endofrecord
```

If we set `rcx` to the `gets` function, after it executes, the program will proceed to execute the `__GI_xdrrec_endofrecord` function. At this point, `rdi` is the `r12` address where we just wrote our data. Let's trace this function further:

```assembly
# 1606DA
mov    rbx, qword ptr [rdi + 0x18]
mov    rdx, qword ptr [rbx + 0x20] # rdx->0x20
mov    rcx, qword ptr [rbx + 0x30] # rcx->0x30
mov    rax, rdx
sub    rax, rcx
sub    rax, 4
or     eax, 0x80000000
bswap  eax
test   esi, esi
jne    xdrrec_endofrecord+88      

mov    rsi, qword ptr [rbx + 0x18] # rsi->0x18
mov    rdi, qword ptr [rbx]        # rdi->0x0
mov    dword ptr [rbx + 0x38], 0
mov    dword ptr [rcx], eax
sub    rdx, rsi
mov    rbp, rdx
call   qword ptr [rbx + 0x10]      # func->0x10
```

Here, by controlling `rdi` (the data we wrote in the previous step), we can control a series of registers. We choose the following gadget:

> `0x000000000005a120: mov rsp, rdx; ret;`

This allows us to successfully pivot the stack to a controllable address where we can write and execute our ROP chain. The final point to note is that to output the flag, the randomized file descriptor (`fd`) must be used as the `fd` for the `write` system call. With this, we can successfully retrieve our flag file.

### Unintended Solutions

The intended solution for this challenge was to see if, given the ability to only read/write within the heap and ELF address ranges, one could find a tricky function pointer to achieve arbitrary function execution. The goal was to encourage players to think outside the box of typical heap exploitation techniques, avoiding any I/O-related exploits and instead finding suitable gadgets within the binary itself.

However, during the competition, some teams bypassed my checks. In the sort function, it was mentioned that the result of `a/b` is written to `c` as long as `c` is 0. There was no check to ensure that the pointers `a`, `b`, and `c` were valid pointers. By setting the pointer `a` to an arbitrary address and the value of `b` to 1, it was possible to leak the content of any address into a heap address. Conversely, by pointing `c` to an arbitrary address that initially contained 0, it was possible to write to an arbitrary address (that was previously empty). The player from team Lilac used this method to overwrite `_IO_2_1_stdin->file->_chain` and finally hijacked the control flow by triggering the `exit` function.

Additionally, a player from team `laogong` used a special gadget:

> `0x00000000001ba784 : add byte ptr [rcx - 0x7b], cl ; ret`

Through multiple additions (?), they set up `__io_list_all` and finally hijacked the pointer to trigger `exit`.

### Some Interesting Gadgets

First, from team "Friendly Maltese Citizens", a first-blood exploit. They chose:

> ```assembly
> #libc.so.6
> .text:000000000015D357                 mov     rdi, xdrs
> .text:000000000015D35A                 call    rcx
> ```

And set `rcx` to:

> ```assembly
> #pwn
> .text:0000000000002AD5                 mov     [rbp+var_18], rdi
> .text:0000000000002AD9                 mov     [rbp+var_1C], esi
> .text:0000000000002ADC                 mov     [rbp+var_4], 0
> .text:0000000000002AE3                 mov     [rbp+var_4], 0
> .text:0000000000002AEA                 jmp     short loc_2B35
> .text:0000000000002AEC ; ---------------------------------------------------------------------------
> .text:0000000000002AEC
> .text:0000000000002AEC loc_2AEC:                               ; CODE XREF: sub_2AC9+72â†“j
> .text:0000000000002AEC                 mov     eax, [rbp+var_4]
> .text:0000000000002AEF                 movsxd  rdx, eax
> .text:0000000000002AF2                 mov     rax, [rbp+var_18]
> .text:0000000000002AF6                 add     rax, rdx
> .text:0000000000002AF9                 mov     edx, 1          ; nbytes
> .text:0000000000002AFE                 mov     rsi, rax        ; buf
> .text:0000000000002B01                 mov     edi, 0          ; fd
> .text:0000000000002B06                 call    _read
> .text:0000000000002B0B                 mov     eax, [rbp+var_4]
> .text:0000000000002B0E                 movsxd  rdx, eax
> .text:0000000000002B11                 mov     rax, [rbp+var_18]
> .text:0000000000002B15                 add     rax, rdx
> .text:0000000000002B18                 movzx   eax, byte ptr [rax]
> .text:0000000000002B1B                 cmp     al, 0Ah
> .text:0000000000002B1D                 jnz     short loc_2B31
> .text:0000000000002B1F                 mov     eax, [rbp+var_4]
> .text:0000000000002B22                 movsxd  rdx, eax
> .text:0000000000002B25                 mov     rax, [rbp+var_18]
> .text:0000000000002B29                 add     rax, rdx
> .text:0000000000002B2C                 mov     byte ptr [rax], 0
> .text:0000000000002B2F                 jmp     short loc_2B3D
> .text:0000000000002B31 ; ---------------------------------------------------------------------------
> .text:0000000000002B31
> .text:0000000000002B31 loc_2B31:                               ; CODE XREF: sub_2AC9+54â†‘j
> .text:0000000000002B31                 add     [rbp+var_4], 1
> .text:0000000000002B35
> .text:0000000000002B35 loc_2B35:                               ; CODE XREF: sub_2AC9+21â†‘j
> .text:0000000000002B35                 mov     eax, [rbp+var_4]
> .text:0000000000002B38                 cmp     eax, [rbp+var_1C]
> .text:0000000000002B3B                 jl      short loc_2AEC
> .text:0000000000002B3D
> .text:0000000000002B3D loc_2B3D:                               ; CODE XREF: sub_2AC9+66â†‘j
> .text:0000000000002B3D                 mov     eax, [rbp+var_4]
> .text:0000000000002B40                 leave
> .text:0000000000002B41                 retn
> .text:0000000000002B41 ; } // starts at 2AC9
> ```

This approach cleverly utilizes the original program's string input function. With `rbp` as `rdi` and `rsi` as a randomly generated key value, as long as the key is large enough, it allows for writing a ROP chain directly, enabling a second-stage read to write a complete ROP chain onto the stack. A very ingenious technique ðŸ˜˜.

Next is the write-up from team "Air2top", who chose to combine three different gadgets to complete the exploit:

```python
gad1 = libc_base + 0x72D44 # mov rdi, r14; call qword ptr [rcx+38h]
gad2 = libc_base + 0x167420# mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]
gad3 = libc_base + 0x29EAC # add r14, 8; mov qword ptr [rsp], rdx; mov rsi, r12; mov edi, ebp; call qword ptr [rcx];
```

The third gadget is used multiple times to increment the `r14` register until it points to the BSS. Then, the first gadget is used, with the address of the second gadget pre-written at `[rcx+38h]`. This jumps to the second gadget. At this point, `rdi` is an address in the BSS that we can read and write arbitrarily, making `rdx` controllable. Combined with the classic `setcontext` gadget to control `rcx`, this allows for the rest of the exploit. Although this method is very complex, it's also very interesting ðŸ¥³ I really like this solution\~
